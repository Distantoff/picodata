# Команды SQL
Данный справочник предоставляет основные варианты использования команд SQL в Picodata при работе с распределенной СУБД.

Функциональность компонента Sbroad в Picodata обеспечивает поддержку
распределенных запросов для записи и чтения данных. На верхнем уровне
схема возможных SQL-запросов в Picodata включает команды для собственно
манипуляции данными (DML), к которым относятся `SELECT` и `INSERT`, а
также отдельную команду `EXPLAIN` для анализа и планирования DML-запросов ([подробнее](#explain)).

Это отражено на схеме ниже: 

### **STATEMENT**
![Statement](ebnf/STATEMENT.svg)


В свою очередь, схема возможных DML-запросов имеет следующий вид:

### **DML**
![DML](ebnf/DML.svg)

Ниже приведены особенности синтаксиса команд и дано описание часто используемых команд с примерами их выполнения.

## Использование SQL-команд в консоли Picodata
После подключения в консоли к узлу-маршрутизатору (роль `vshard.router`), можно
выполнять SQL-команды, т.е. добавлять данные в [спейсы](../glossary.md#space) (таблицы) и
получать их. Синтаксис команд учитывает особенности Lua-интерпретатора в
консоли Picodata и предполагает, что любой SQL-запрос должен содержаться
в обертке следующего вида: 
```
sbroad.execute([[запрос]], {значения передаваемых параметров})
```

Команды Sbroad будут отличаться в зависимости от того, записываем ли мы в БД данные (`INSERT`) или считываем их (`SELECT`).
Так как при SELECT-запросах мы не передаем каких-либо параметров, то содержимое фигурных скобок будет пустым. Пример:
```
sbroad.execute([[select * from "characters"]], {})
```

Запись строки данных в таблицу командой `INSERT` возможна как в обычном виде:
```
sbroad.execute([[insert into "characters" ("id", "name", "year") values (1, 'Woody', 1995)]], {})
```
Так и параметризированном:
```
sbroad.execute([[insert into "characters" ("id", "name", "year") values (?, ?, ?)]], {1, "Woody", 1995})
```

Ниже приведены подробности использования SQL-команд в Picodata.

## Запрос SELECT

Запрос `SELECT` используется для получения информации из указанной
таблицы в базе данных. Он возвращает 0 или более строк из таблицы
согласно поисковому запросу. В контексте распределенной системы, запрос
`SELECT` в Picodata получает информацию из всех сегментов таблицы,
которая может храниться на нескольких узлах кластера. В Picodata
источником данных для запроса `SELECT` может выступать таблица, строка
значений или другой подзапрос. Также можно соединять несколько запросов
одного уровня вместе.

Cхема возможных распределенных запросов `SELECT` показана ниже.

### **SELECT**
![Select](ebnf/SELECT.svg)


### Примеры запросов

Для примера используем два тестовых спейса для учета персонажей из "Истории игрушек":

- `characters` — список персонажей с указанием года выхода на экран;
- `assets` — список соответствующих игрушек с указанием их остатков на складе.

![Table_characters](table_characters.svg)

![Table_assets](table_assets.svg)


Ниже показаны некоторые примеры работающих SQL-запросов с использованием данных из этих таблиц.

Вывод всей таблицы:
```
sbroad.execute([[select * from "characters"]], {})
```

Вывод в консоль:
```
---
- {
  'metadata': [
    {'name': 'id', 'type': 'integer'},
    {'name': 'name', 'type': 'string'},
    {'name': 'year', 'type': 'integer'}], 
  'rows': [
    [1, 'Woody', 1995], 
    [3, 'Bo Peep', 1995],
    [7, 'Daisy', 2010], 
    [8, 'Forky', 2019], 
    [2, 'Buzz Lightyear', 1995],
    [4, 'Mr. Potato Head', 1995], 
    [5, 'Slinky Dog', 1995], 
    [6, 'Barbie', 2010], 
    [9, 'Dragon', 2019], 
    [10, 'The Dummies', 2019]]
    }
...

```
_Примечание_: строки в выводе идут в том порядке, в каком их отдают узлы хранения Picodata (с ролью `vshard.storage`).

Вывод строки по известному `id`:
```
sbroad.execute([[select "name" from "characters" where "id"=1]], {})
```

Вывод в консоль:
```
---
- {'metadata': [{'name': 'name', 'type': 'string'}], 'rows': [['Woody']]}
...
```

Вывод строк по нескольким условиям для разных столбцов:
```
sbroad.execute([[select "name","year" from "characters" where "id">3 and "year">2000 ]], {})
```

Вывод в консоль:
```
---
- {
  'metadata': [
    {'name': 'name', 'type': 'string'},
    {'name': 'year', 'type': 'integer'}],
  'rows': [
    ['Daisy', 2010], 
    ['Forky', 2019], 
    ['Barbie', 2010], 
    ['Dragon', 2019], 
    ['The Dummies', 2019]]
    }
...

```

Структурно SQL-запрос состоит из трех частей:

1. То, что требуется получить
2. Разделяющий оператор `from`
3. Оставшаяся часть запроса, которая логически представляет собой одну
   сущность и может включать как простое указание на таблицу, так и
   конструкцию из разных условий.

### **values**

![Column](ebnf/VALUES.svg)


### **row**

![Column](ebnf/row.svg)



### **column**

![Column](ebnf/column.svg)



### **expression**

![Expression](ebnf/expression.svg)



### **reference**

![Reference](ebnf/reference.svg)



### **value**

![Value](ebnf/value.svg)



### **type**

![Type](ebnf/type.svg)



## Использование VALUES
Команда `VALUES` представляет собой конструктор строки значений для
использования в запросе `SELECT`. В некотором смысле, передаваемые с
`VALUES` значения являются временной таблицей, которая существует только
в рамках запроса. Использовать `VALUES` имеет смысл тогда, когда
требуется получить набор строк, для которых известны значения одного или
более столбцов. Например, с помощью команды ниже можно выяснить название
игрушки, зная её количество на складе:

```
sbroad.execute([[select "name" from "assets" where ("stock") in (values (2561))]], {})
```
Вывод в консоль:
```
---
- {'metadata': [{'name': 'name', 'type': 'string'}], 'rows': [['Woody']]}
...

```


## Использование UNION ALL
Команда `UNION ALL` используется для соединения результатов нескольких
запросов. Это может быть полезно для объединения данных из нескольких
таблиц, или для удобного отображения разных вычислений или манипуляций
со строками таблицы. Результат запроса может содержать дублирующиеся строки.

Для примера предположим, что требуется получить список игрушек с
персонажами 1995 года, а также все игрушки, остатки которых на складе
превышают 1000 штук:

```
sbroad.execute([[select "name"  from "characters" where "year"=1995 union all select "name" from "assets" where "stock">1000]], {})
```

Вывод в консоль:
```
---
- {
  'metadata': [
    {'name': 'name', 'type': 'string'}],
 'rows': [
    ['Woody'], 
    ['Bo Peep'],
    ['Woody'], 
    ['Buzz Lightyear'], 
    ['Mr. Potato Head'], 
    ['Slinky Dog'], 
    ['Buzz Lightyear'],
    ['Slinky Dog']]
    }
...
```

## Использование EXCEPT
Команда `EXCEPT` используется для соединения нескольких запросов
`SELECT` по принципу исключения. Это означает, к примеру, что из
результата первого запроса будут исключены результаты второго, если
между ними есть пересечение. `EXCEPT` может применяться при запросах из
разных таблиц, либо разных столбцов одной таблицы, когда нужный
результат нельзя получить лишь одним SELECT-запросом.

Используем команду, похожую на предыдущий пример, но с другим смыслом.
На этот раз нужно получить список игрушек с персонажами 1995 года, но
только если их запасы меньше 1000 штук: 

```
 sbroad.execute([[select "name"  from "characters" where "year"=1995 except select "name" from "assets" where "stock">1000]], {})
```
Вывод в консоль:
```
---
- {
  'metadata': [
    {'name': 'name', 'type': 'string'}], 
  'rows': [
    ['Bo Peep'], 
    ['Mr. Potato Head']]
    }
...
```
## Использование псевдонимов
Использование псевдонимов (aliases) позволяет переопределить названия
получаемых столбцов в SELECT-запросах. Псевдоним вставляется после
ключевого слова `AS` и может содержать произвольный текст со следующими
ограничениями: он не должен начинаться с цифры и не может содержать
пробелов и специальных служебных символов (кроме знака подчеркивания).

Пример для вывода столбцы таблицы:
```
sbroad.execute([[select "score" as "Total_score" from "scoring"]], {})
---
- {
  'metadata': [
    {'name': 'Total_score', 'type': 'decimal'}], 
  'rows': [
    [78.33],
    [84.61],
    [47.28]]
    }
...
```

Пример для функции `CAST()`:
```
sbroad.execute([[select sum(cast("score" as int)) as "_Total_score_1" from "scoring"]], {})
---
- {
  'metadata': [
    {'name': '_Total_score_1', 'type': 'decimal'}], 
  'rows': 
  [[209]]}
...
```

## Использование JOIN
Команда `JOIN` используется для комбинирования данных из нескольких
таблиц. Но, в отличие от `UNION ALL`, результатом будет объединение не
строк, а столбцов. Таким образом, если `UNION ALL` добавляет к строкам
одной таблицы строки другой (при условии совпадения типов данных в
соответствующих столбцах), то `JOIN` создает новую результирующую
таблицу из указанных столбцов этих таблиц. Использование `JOIN` полезно
для соединения связанных друг с другом данных из разных таблиц.
Склеивание столбцов требует указания условия (оператор `ON`). Для
примера создадим из двух таблицы выше новую результирующую таблицу, где
будут одновременно и остатки игрушек на складе, и годы выхода
соответствующих персонажей:

![Table_joined](table_joined.svg)

Команда:

```
sbroad.execute([[select "id","name","stock","year" from "characters" join (select "id" as "number","stock" from "assets") as stock on "characters"."id"=stock."number"]], {})
```


Вывод в консоль:
```
---
- {
  'metadata': [
    {'name': 'characters.id', 'type': 'integer'}, 
    {'name': 'characters.name', 'type': 'string'}, 
    {'name': 'STOCK.stock', 'type': 'integer'}, 
    {'name': 'characters.year', 'type': 'integer'}], 
  'rows': [
    [1, 'Woody', 2561, 1995], 
    [3, 'Bo Peep', 255, 1995], 
    [7, 'Daisy', 66, 2010], 
    [8, 'Forky', 341, 2019], 
    [2, 'Buzz Lightyear', 4781, 1995], 
    [4, 'Mr. Potato Head', 109, 1995], 
    [5, 'Slinky Dog', 1112, 1995],
    [6, 'Barbie', 998, 2010], 
    [9, 'Dragon', 235, 2019], 
    [10, 'The Dummies', 78, 2019]]
    }
...

```
Если после оператора `JOIN` следует подзапрос (как в примере выше), то
обязательно использование псевдонима (`AS`). С помощью дополнительных
псевдонимов можно заменить автоматические имена колонок в результирующей
таблице на собственные. Новые имена не должны совпадать с прежними:

```
 sbroad.execute([[select "id" as "id1","name" as "name1","stock" as "stock1","year" as "year1" from "characters" join (select "id" as "number","stock" from "assets") as stock on "characters"."id"=stock."number"]], {})
```

Вывод в консоль:
```
---
- {
  'metadata': [
    {'name': 'id1', 'type': 'integer'}, 
    {'name': 'name1', 'type': 'string'},
    {'name': 'stock1', 'type': 'integer'}, 
    {'name': 'year1', 'type': 'integer'}],
  'rows': [
    [1, 'Woody', 2561, 1995], 
    [3, 'Bo Peep', 255, 1995], 
    [7, 'Daisy', 66, 2010],
    [8, 'Forky', 341, 2019], 
    [2, 'Buzz Lightyear', 4781, 1995], 
    [4, 'Mr. Potato Head', 109, 1995], 
    [5, 'Slinky Dog', 1112, 1995], 
    [6, 'Barbie', 998, 2010], 
    [9, 'Dragon', 235, 2019], 
    [10, 'The Dummies', 78, 2019]]
    }
...

```

## Использование функции CAST()
Функция `CAST()` используется для изменения получаемого типа данных при
SELECT-запросах. С ее помощью можно преобразовать числа в текст, дробные
числа в целые и так далее согласно приведённой [выше](#type) схеме. В
частности, поддерживаются следующие типы данных:

- `ANY`. Любой тип данных / тип данных не задан;
- `BOOL`, `BOOLEAN`. Логический тип данных, поддерживаемые значения:
  `FALSE`, `TRUE` и `NULL` (`UNKNOWN` в терминологии троичной логики).
  По правилам сравнения `FALSE` меньше `TRUE`.
- `DECIMAL`. Числа с фиксированной запятой, содержащие до 38 цифр;
- `DOUBLE` Числа с плавающей запятой стандарта IEEE 754. Помимо
  стандартной записи дробного числа (например, `0.5`) поддерживается и
  экспоненциальная форма (например, `5E-1`);
- `INT`, `INTEGER`. Целые числа в диапазоне от `-2^63` до `+2^64` или
  `NULL`;
- `NUMBER`. Универсальный числовой контейнер, в котором могут лежать как
  целые числа, так и числа с плавающей запятой;
- `SCALAR`. Скалярный тип данных, т.е содержащий только один элемент
  (_не_ кортеж и _не_ массив);
- `STRING`, `TEXT`. Текстовый тип данных. Позволяет хранить текстовую
  строку переменной длины. Максимальная длина составляет `2,147,483,647`
  байт;
- `UNSIGNED`. Тип целого беззнакового числа в диапазоне от `0` до
  `+2^64` или `NULL`.
- `VARCHAR`. Текстовый тип данных с явно заданной длиной строки.

### Пример запроса
В качестве примера покажем преобразование дробных чисел в целые с отбрасыванием дробной части.
Используем следующую таблицу:

![Table_scores](table_scores.svg)

В обычном виде значения столбца `score` имеют дробную часть и определены в схеме данных типом `decimal`:
```
sbroad.execute([[select "score" from "scoring"]], {})
---
- {
  'metadata': [
   {'name': 'score', 'type': 'decimal'}], 
  'rows': [
    [78.33],
    [84.61],
    [47.28]]
    }
...

```
Преобразуем эти числа в `int`:
```
sbroad.execute([[select cast("score" as int) from "scoring"]], {})
---
- {
  'metadata': [
  {'name': 'COL_1', 'type': 'integer'}],
  'rows': [
  [78],
  [84],
  [47]]
  }
...
```

## Запрос INSERT
Запрос `INSERT` используется для помещения (записи) строки данных в
таблицу. На данный момент доступна запись только одной строки в рамках
одного запроса.

Схема возможных запросов `INSERT` показана ниже.


![Insert](ebnf/INSERT.svg)

### Пример запроса
Пример использования со вставкой строки значений в таблицу при помощи команды `INSERT`:

```
sbroad.execute([[insert into "assets" ("id", "name", "stock") values (?, ?, ?)]], {1, "Woody", 2561})
```

В данном случае использовалась параметризированная вставка с явным
указанием столбцов таблицы. Если вставляемая строка точно содержит
значения для всех столбцов, то их можно явно не указывать:

```
sbroad.execute([[insert into "assets" values (1, 'Woody', 2561)]], {})
```

Вывод в консоль при успешной вставке:

```
---
- {'row_count': 1}

```


## Запрос EXPLAIN
Команда `EXPLAIN` добавляется перед командами `SELECT` и `INSERT` для
того чтобы показать как будет выглядеть план исполнения запроса, при этом не выполняя
сам запрос. План строится на узле-маршрутизаторе (роль `vshard.router`) и
позволяет наглядно оценить структуру и последовательность действий при
выполнении запроса. `EXPLAIN` является инструментом для анализа и
оптимизации запросов.

Схема использования `EXPLAIN` показана ниже.


### **EXPLAIN**
![Explain](ebnf/EXPLAIN.svg)

### Простые запросы
Для начала рассмотрим план простого запроса на получение данных одного столбца таблицы:

```
sbroad.execute([[explain select "score" from "scoring"]], {})
```

Вывод в консоль:
```
---
- [
  'projection ("scoring"."score" -> "score")', 
  '    scan "scoring"']
...
```
Обязательными элементами плана запроса являются `scan` и `projection`.
Первый узел отвечает за сканирование (получение данных) таблицы, второй
— за выборку нужных столбцов. Построение проекции (`projection`) всегда
происходит после сканирования. В рамках построения проекции планировщик
создает псевдоним для столбца: `"scoring"."score" -> "score"`.

Если в запросе есть условие (`where`), то в план добавляется узел `selection`:

```
sbroad.execute([[explain select "score" from "scoring" where "score">70]], {})
```

Вывод в консоль:
```
---
- [
  'projection 
  ("scoring"."score" -> "score")', 
  '    selection ROW("scoring"."score") > ROW(70)', 
  '        scan "scoring"']
...
```
Если `projection` выбирает столбцы (атрибуты таблицы), то `selection`
фильтрует данные по строкам (`ROW`).

Фраза `selection ROW("scoring"."score") > ROW(70)'` является результатом
трансформации фильтра `where "score" > 70` в `where ("score") > (70)`, т.е.
превращения значения в строку из одного столбца. 

### Запрос с несколькими проекциями
Пример построения проекции из более сложного запроса:

```
sbroad.execute([[explain select "id","name"  from "characters" except select "id","name" from "assets" where "stock">1000]], {})
```

Вывод в консоль:
```
- [
  'except', 
  '    projection ("characters"."id" -> "id", "characters"."name" -> "name")',
  '        scan "characters"', 
  '    projection ("assets"."id" -> "id", "assets"."name" -> "name")', 
  '        selection ROW("assets"."stock") > ROW(1000)', 
  '            scan "assets"'
  ]
...


```
В таком плане запроса присутствует два блока `projection`, перед
которыми стоит логическое условие (`except`). В каждом блоке есть свое
сканирование таблицы и, опционально, дополнительный фильтр по строкам
(`selection`).

### Варианты перемещения данных
В плане запроса может быть указан параметр `motion`, который отражает
тип перемещения данных между узлами хранения. Существуют следующие два
типа:

1. **Частичный**. При выполнении запроса на каждый узел кластера будет
   отправлена только востребованная часть данных (таблица
   перераспределяется по новому ключу). При таком запросе планировщик
   отобразит значение `motion [policy:   segment]`.
1. **Полный**. На каждый узел кластера будет отправлена вся таблица.
   Планировщик отобразит значение `motion [policy:   full]`.

Вариант перемещения данных определяется характером распределения спейса
между репликами (шардами) и зависит от типа запроса. Распределенный
запрос выполняется отдельно на каждом шарде, после чего результаты
соединяются (см. [подробнее](sql_review.md)). При выполнении
распределенного `EXCEPT` требуется полное перемещение таблицы в правой
части запроса на все шарды, содержащие таблицу из левой части (без этого
результаты локальных запросов будут неверными). Аналогично, для
объединения нескольких таблиц требуется наличие полной копии
присоединяемой таблицы на всех шардах для того, чтобы распределенный
`JOIN` смог корректно соединить столбцы разных таблиц.

Частичное перемещение данных характерно для распределенного `INSERT`,
при котором перемещаются только те колонки, по которым таблица
шардирована (`sharding_key` в схеме данных).

При работе с одной таблицей, либо независимом выполнении запросов на
разных таблицах без их взаимодействия (например, при распределенном
`UNION ALL`), перемещение данных не происходит. 

#### Пример `motion [policy:   segment]`.
```
sbroad.execute([[explain insert into "assets" ("id", "name", "stock") values (?, ?, ?)]], {12, "Sid Phillips", 98})
```
Вывод в консоль:
```
---
[
 'insert "assets"', 
 '    projection (COL_0 -> COL_0, COL_1 -> COL_1, COL_2 -> COL_2, bucket_id((coalesce((''NULL'', COL_0::string)) || coalesce((''NULL'', COL_1::string)))))',
 '        scan', 
 '            projection (COLUMN_1::int -> COL_0, COLUMN_2::string -> COL_1, COLUMN_3::int -> COL_2)', 
 '                scan', 
 '                    motion [policy: segment([ref(COLUMN_1), ref(COLUMN_2)])]', 
 '                        values',
 '                            value row (data=ROW(12, ''Sid Phillips'', 98))'
]
...
```

#### Пример `motion [policy:   full]`.
```
sbroad.execute([[explain select "id","name","stock","year" from "characters" join (select "id" as "number","stock" from "assets") as stock on "characters"."id"=stock."number"]], {})
```

Вывод в консоль:
```
---
- [
  'projection (
    "characters"."id" -> "id", 
    "characters"."name" -> "name", 
    "STOCK"."stock" -> "stock", 
    "characters"."year" -> "year")', 
    '    join on ROW("characters"."id") = ROW("STOCK"."number")', 
    '        scan "characters"', 
    '            projection (
      "characters"."id" -> "id", 
      "characters"."name" -> "name", 
      "characters"."year" -> "year")', 
      '                scan "characters"', 
      '        motion [policy: full]',
      '            scan "STOCK"', 
      '                projection (
        "assets"."id" -> "number",
        "assets"."stock" -> "stock")', 
        '                    scan "assets"'
    ]

...
```
Читать далее: [Поддерживаемые типы данных SQL](../sql_datatypes)
<!-- ebnf source: https://git.picodata.io/picodata/picodata/sbroad/-/blob/main/doc/sql/query.ebnf -->

---
[Исходный код страницы](https://git.picodata.io/picodata/picodata/docs/-/blob/main/docs/sbroad/sql_queries.md)
