# Пример работы с кластером Picodata
В данном разделе приведены практические примеры команд, которые помогут
сделать первые шаги в управлении распределенным кластером Picodata. В
частности, в данном разделе рассмотрены следующие вопросы:

* Запуск кластера
* Мониторинг состояния кластера
* Первые действия в только что созданном кластере
* Запись и чтение данных в кластере
* Балансировка данных в кластере

## Запуск кластера
Запуск кластера сводится к выполнению команды `picodata run` с нужным
набором параметров для каждого инстанса (узла). Полный перечень
возможных параметров запуска и их описание содержатся в подразделе
[Описание параметров запуска](../cli), а также в выводе команды
`picodata run --help`. С точки зрения внутренней архитектуры, _кластер_
  корректно называть _raft-группой_ — в дальнейшем при мониторинге и
управлении конфигурацией будет уместнее использовать именно этот термин.
Для данного примера допустим, что в локальном кластере
(127.0.0.1/localhost) будет 4 инстанса с фактором репликации равным 2,
что означает наличие 2-х репликасетов. Запустим первый инстанс, указав
необходимые параметры:
```bash
picodata run --init-replication-factor=2 --listen :3301 --data-dir=inst1
```
Следует обратить внимание на следующие моменты:

* Параметр `init-replication-factor` задается лишь один раз в момент
создания кластера и дальше не требуется. Перезапускать данный инстанс в
дальнейшем нужно без этого параметра. 
* Параметр `listen` может содержать только номер порта (по умолчанию для
первого инстанса используется 3301), что означает указание
использовать _текущий_ хост. В настоящем распределенном кластере
указывать IP-адрес в данном параметре обязательно.
* Параметр `data-dir` указывает на директорию, в которой будут храниться
персистентные данные инстансы (файлы `*.snap` и `*.xlog`). Если при
первом запуске задать несуществующую директорию, то она будет
автоматически создана. 
* Будет создан кластер со стандартным названием `demo`, т.к. явно не
указан параметр `cluster-id` (см. [подробнее](../cli)).

Аналогично следует запустить остальные 3 инстанса, указав им разные, отличные от
3301, порты и разные рабочие директории. В случае с кластером на
удаленных узлах, для инстансов также потребуется указать параметр
`peer` (см. [подробнее](../cli)).

## Мониторинг состояния кластера
Для мониторинга состояния кластера удобно использовать команды,
показывающие состояние Raft-группы, отдельных инстансов и собранных из
них репликасетов. Для использования указанных команд следует
сначала подключиться к какому-либо инстансу с помощью команды
`tarantoolctl connect`.
Примеры команд и их выводов приведены ниже.

Узнать лидера Raft-группы, а также ID и статус текущего инстанса:
```
pico.raft_status()
```

Пример вывода:
```
---
- term: 2
  leader_id: 1
  raft_state: Leader
  id: 1
...

```

Просмотр состава Raft-группы и данных инстансов:
```
box.space._pico_instance:fselect()
```
Пример вывода:
```
---
- - ​+-----------+--------------------------------------+-------+-------------+--------------------------------------+-------------+------------+--------------+
  - ​|instance_id|            instance_uuid             |raft_id|replicaset_id|           replicaset_uuid            |current_grade|target_grade|failure_domain|
  - ​+-----------+--------------------------------------+-------+-------------+--------------------------------------+-------------+------------+--------------+
  - ​|   "i1"    |"68d4a766-4144-3248-aeb4-e212356716e4"|   1   |    "r1"     |"e0df68c5-e7f9-395f-86b3-30ad9e1b7b07"|["Online",1] |["Online",1]|      {}      |
  - ​|   "i2"    |"24c4ac5f-4981-3441-879c-aee1edb608a6"|   2   |    "r1"     |"e0df68c5-e7f9-395f-86b3-30ad9e1b7b07"|["Online",1] |["Online",1]|      {}      |
  - ​|   "i3"    |"5d7a7353-3e82-30fd-af0d-261436544389"|   3   |    "r2"     |"eff4449e-feb2-3d73-87bc-75807cb23191"|["Online",1] |["Online",1]|      {}      |
  - ​|   "i4"    |"826cbe5e-6979-3191-9e22-e39deef142f0"|   4   |    "r2"     |"eff4449e-feb2-3d73-87bc-75807cb23191"|["Online",1] |["Online",1]|      {}      |
  - ​+-----------+--------------------------------------+-------+-------------+--------------------------------------+-------------+------------+--------------+
...

```

Просмотр списка репликасетов, их UUID и веса (т.е. приоритета при распределении бакетов):
```
box.space._pico_replicaset:fselect()
```
Пример вывода:
```
---
- — ​+-------------+--------------------------------------+---------+------+
  - ​|replicaset_id|           replicaset_uuid            |master_id|weight|
  - ​+-------------+--------------------------------------+---------+------+
  - ​|    "r1"     |"e0df68c5-e7f9-395f-86b3-30ad9e1b7b07"|  "i1"   |  1   |
  - ​|    "r2"     |"eff4449e-feb2-3d73-87bc-75807cb23191"|  "i3"   |  1   |
  - ​+-------------+--------------------------------------+---------+------+
...

```

Эти и другие команды сведены в
[Bash-скрипт](picodata-list.sh),
который можно загрузить и выполнить для более удобного мониторинга
кластера Picodata (например, командой `watch ./picodata-list.sh`). 

Внешний вид выполняющегося скрипта показан ниже.
```
connected to localhost:3301
---
- instance_id: i1
- raft_state: Leader
- voters: [1, 2, 3]
- learners: [4]
- instances:
  - ​+-----------+--------------------------------------+-------+-------------+--------------------------------------+-------------+------------+--------------+
  - ​|instance_id|            instance_uuid             |raft_id|replicaset_id|           replicaset_uuid            |current_grade|target_grade|failure_domain|
  - ​+-----------+--------------------------------------+-------+-------------+--------------------------------------+-------------+------------+--------------+
  - ​|   "i1"    |"68d4a766-4144-3248-aeb4-e212356716e4"|   1   |    "r1"     |"e0df68c5-e7f9-395f-86b3-30ad9e1b7b07"|["Online",1] |["Online",1]|      {}      |
  - ​|   "i2"    |"24c4ac5f-4981-3441-879c-aee1edb608a6"|   2   |    "r1"     |"e0df68c5-e7f9-395f-86b3-30ad9e1b7b07"|["Online",1] |["Online",1]|      {}      |
  - ​|   "i3"    |"5d7a7353-3e82-30fd-af0d-261436544389"|   3   |    "r2"     |"eff4449e-feb2-3d73-87bc-75807cb23191"|["Online",1] |["Online",1]|      {}      |
  - ​|   "i4"    |"826cbe5e-6979-3191-9e22-e39deef142f0"|   4   |    "r2"     |"eff4449e-feb2-3d73-87bc-75807cb23191"|["Online",1] |["Online",1]|      {}      |
  - ​+-----------+--------------------------------------+-------+-------------+--------------------------------------+-------------+------------+--------------+
- replicasets:
  - ​+-------------+--------------------------------------+---------+---------------------+
  - ​|replicaset_id|           replicaset_uuid            |master_id|       weight        |
  - ​+-------------+--------------------------------------+---------+---------------------+
  - ​|    "r1"     |"e0df68c5-e7f9-395f-86b3-30ad9e1b7b07"|  "i1"   |[1,"Auto","UpToDate"]| 
  - ​|    "r2"     |"eff4449e-feb2-3d73-87bc-75807cb23191"|  "i3"   |[1,"Auto","UpToDate"]| 
  - ​+-------------+--------------------------------------+---------+---------------------+
...

```

Данный скрипт выполняет, в частности, следующие действия:

* При выполнении без аргументов подключается к первому локальному
инстансу localhost:3301 с помощью консоли `tarantoolctl`. В качестве
аргумента скрипту можно передать произвольное значение `<host:port>`.
* Выводит идентификатор (значение `instance_id`) текущего инстанса.
* Выводит статус текущего инстанса в Raft.
* Выводит количество голосующих/неголосующих узлов (`voters`/`learners`) в кластере.
* Выводит таблицы со списками инстансов и репликасетов.
* Позволяет узнать текущий и целевой уровень (`grade`) каждого инстанса,
а также вес (`weight`) репликасета. Уровни отражают конфигурацию
остальных инстансов относительно текущего, а вес репликасета — его
наполненность репликами согласно фактору репликации (см.
[подробнее](../clustering)).


## Создание таблицы данных (спейса)
Перед тем как начать пользоваться СУБД, необходимо создать таблицу,
которая в терминологии Tarantool называется спейс (space). Таблица
является необходимым элементом схемы данных, распространяемой на все
узлы кластера. Каждое действие по созданию/удалению таблиц в Picodata
увеличивает номер схемы данных. В пустом кластере изначально схема
данных имеет индекс 0, после чего он инкрементируется при каждом
изменении содержимого кластера. Любое действие по
созданию/изменению/удалению таблиц, работы с индексами хранения и т.д.
является изменением схемы данных. В Picodata поддерживается два вида
спейсов: 
1. Глобальные (_global_) — их содержимое реплицируется на весь
кластер.
1. Шардированные (_sharded_) — каждый репликасет хранит лишь часть
общего набора данных. Данные реплицируются внутри репликасета.

После подключения к инстансу кластера посредством команды `picodata
connect`, начальным действием в пустом кластере будет создание первой
таблицы/space. Пусть это будет шаблон списка друзей Свинки Пеппы, в
котором будет два поля: идентификатор записи и имя друга:

```
pico.create_space({ name = 'friends_of_peppa', format = { {name='id', type='unsigned', is_nullable=false}, {name='name', type='string', is_nullable=true} }, primary_key = { 'id' }, distribution = 'global' }, 3.0)
```

Ключ _distribution_ отвечает за тип спейса. В примере указан глобальный
тип (_global_); для шардированного следует указать тип _sharded_.
Значение “3.0” означает таймаут в секундах перед возвращением управления
пользователю (т.к. действие производится на всем кластере, то оно может
занять продолжительное время).
Для ключа `type` допустимы следующие значения:  any | unsigned | string | integer | number | varbinary | boolean | double | decimal | uuid | array | map | scalar.

Пример создания шардированного спейса:

```
pico.create_space{ name = 'friends_of_peppa', format = { {name='id',
type='unsigned', is_nullable=false}, {name='name', type='string', is_nullable=true} }, primary_key = { 'id' },
distribution = 'sharded', sharding_key = { 'id' }, timeout = 3.0 }
```

Посмотрим на текущую версию схему данных:
```
box.space._pico_property:get("current_schema_version")
---
- ['current_schema_version', 1] 
...
```

В дальнейшем каждое изменение схемы данных в кластере будет приводить к
увеличению этого номера. Первичный индекс таблицы для шардированных
спейсов создается автоматически.

## Запись данных в глобальный спейс
В случае с глобальным спейсом, запись данных, т.е. вставка строк, происходит с помощью следующей команды:
```
pico.cas({space = 'friends_of_peppa', kind = 'insert', tuple = {1, "Susie"} }, { index = box.space._raft_state:get('applied').value, term = box.space._raft_state:get('term').value, ranges = {} })
```

## Запись данных в шардированный спейс
Для записи данных в шардированный спейс можно использовать функцию записи из состава библиотеки _vshard_:
```
vshard.router.callrw (1, "box.space.friends_of_peppa:insert", {{1, "Susie"}})
```
Здесь первая и третья 1 — номер бакета, вторая — номер записи. Можно делать множество записей с разными номерами в один и тот же бакет. Пример для 4-й записи в 2000-м бакете:
```
vshard.router.callrw (2000, "box.space.friends_of_peppa:insert", {{4, "Rebecca"}})
```

## Чтение данных
Для чтения данных из глобального спейса подойдёт команда:
```
box.space.friends_of_peppa:select()
```

Отдельно можно узнать, какие именно поля (названия столбцов) есть спейсе:
```
box.space.friends_of_peppa:format()
```
Чтение данных из шардированного спейса происходит посредством вызова vshard. Например:
```
vshard.router.callro (2000, "box.space.friends_of_peppa:select")
```

## Балансировка данных
### Работа с бакетами
Относительно бакетов в Picodata используются умолчания, принятые в СУБД
Tarantool, согласно которым в кластере всегда доступны 3000 бакетов.
Размер бакета динамичен: он определяется размером хранимых в нем данных.
Бакеты равномерно распределяются между репликасетами. В приведенном
здесь примере кластера из двух репликасетов, один из них хранит
диапазон бакетов от 0 до 1500, а второй — от 1501 до 3000.

Для того чтобы просмотреть хранящиеся в текущем репликасете бакеты,
используйте следующую команду:

```bash
box.space.test1:fselect()
```

Соответственно, если нужного бакета в списке нет, то он хранится в
другом репликасете, и данную команду нужно выполнять на нем. Просмотреть
список бакетов на текущем инстансе можно так:
```bash
box.space._bucket:fselect()
```
Балансировка данных в Picodata происходит автоматически при изменении
конфигурации кластера, например при добавлении новых инстансов. Во время
балансировки изменяется распределение бакетов между репликасетами. К
примеру, если в кластере добавится новый полный (с весом 1) репликасет,
то часть бакетов автоматически переедет на него. Это можно будет
заметить при выполнении команды `box.space._bucket:fselect()`.

### Создание шардированной таблицы

Рассмотрим пример с шардированием данных в кластере Picodata.

Запустим кластер из двух экземпляров:

```bash
picodata run  --listen localhost:3301 --instance-id i1 --cluster-id c1 --peer localhost:3301,localhost:3302,localhost:3303
picodata run  --listen localhost:3302 --instance-id i2 --cluster-id c1 --peer localhost:3301,localhost:3302,localhost:3303
```

Создадим шардированную таблицу (space). Ключевым моментом является создание индекса `bucket_id` в space (его наличие помечает space как шардированный):
    
```bash
pico.add_migration(1, 'create table t2(a int, "bucket_id" unsigned, primary key (a));')
pico.add_migration(2, 'create index "bucket_id" on t2 ("bucket_id");')
pico.migrate(2)
```
 
Заполним шардированный space (все 3000 бакетов) тестовыми данными:

```lua
 for i=1,3000 do vshard.router.callrw(i, 'box.space.T2:insert', {{i, i}}) end
```

Проверим, что данные поровну распределились между экземплярами. На каждом из них (`i1`, `i2`) выполним запрос:
```lua
vshard.storage.info().bucket
```

В результате мы получим по 1500 бакетов на каждом экземпляре:
```
 ---
 - receiving: 0
 active: 1500
 total: 1500
 garbage: 0
 pinned: 0
 sending: 0
 ...
```
Добавим еще один экземпляр:
```sh
picodata run  --listen localhost:3303 --instance-id i3 --cluster-id c1 --peer localhost:3301,localhost:3302,localhost:3303
```

Запустим ребалансировку данных. Важный момент: ребалансер бакетов работает на экземпляре с наименьшим значением `instance_uuid` из спейса `_picodata_instance`:
```sql
\set language sql
 select "instance_uuid", "instance_id" from "_picodata_instance"
 \set language lua
```
В результате получим:
```
---
- metadata:
- name: instance_uuid
    type: string
- name: instance_id
    type: string
rows:
- ['68d4a766-4144-3248-aeb4-e212356716e4', 'i1']
- ['24c4ac5f-4981-3441-879c-aee1edb608a6', 'i2']
- ['5d7a7353-3e82-30fd-af0d-261436544389', 'i3']
...
```
В данном случае наименьшее значение UUID имеет экземпляр `i2` (т.к. в число `24c4ac5f-4981-3441-879c-aee1edb608a6` в байтовом представлении меньше остальных). Поэтому ребалансировка будет запущена на нем (но мы для примера запустим ее вручную):
```lua
vshard.storage.rebalancer_wakeup()
```
Проверим, что данные перераспределились между тремя экземплярами. На каждом из них (`i1`, `i2` и `i3`) выполним запрос:
```lua
vshard.storage.info().bucket
```
В результате мы получим по 1000 бакетов на каждом экземпляре:
```
---
- receiving: 0
active: 1000
total: 1000
garbage: 0
pinned: 0
sending: 0
...
```


Подробнее о внутренней архитектуре кластера Picodata см. в разделе
[Общая схема инициализации кластера](../clustering). Параметры запуска
из командной строки описаны в разделе [Описание параметров
запуска](../cli).

---
[Исходный код страницы](https://git.picodata.io/picodata/picodata/docs/-/blob/main/docs/tutorial.md)

