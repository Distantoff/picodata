# Общая схема инициализации кластера
Данный документ описывает высокоуровневый процесс инициализации кластера Picodata на основе нескольких отдельно запущенных экземпляров Picodata (инстансов).

Администратор запускает несколько инстансов, передавая в качестве аргументов необходимые параметры:

```sh
picodata run --instance-id i1 --listen i1 --peer i1,i2
picodata run --instance-id i2 --listen i2 --peer i1,i2
picodata run --instance-id i3 --listen i3 --peer i1,i2
# ...
picodata run --instance-id iN --listen iN --peer i1,i2
```

Независимо от количества запускаемых инстансов, в опции `--peer` у каждого из них следует указать один и тот же набор из нескольких инстансов - обычно первых двух. Именно на их основе будет произведена инициализация кластера и поиск всех работающих инстансов для их включения в состав кластера (discovery).

Подробности алгоритма discovery приведены в отдельном [документе](discover.md). В контексте сборки кластера важно лишь понимать, что этот алгоритм позволяет лишь одному инстансу/peer'у создать Raft-группу, т.е. стать инстансом с raft_id=1. Если таких инстансов будет несколько, то и Raft-групп, а следовательно и кластеров Picodata получится несколько.

Топологией Raft-группы управляет алгоритм Raft, реализованный в виде крейта `raft-rs`.

# Этапы инициализации кластера
На схеме ниже показаны этапы жизненного цикла инстанса в контексте его присоединения ко кластеру Picodata.

![main.rs](clustering_curves.svg "main.rs control flow")

Красным показан родительский процесс, который запущен на всём протяжении жизненного цикла инстанса. Вся логика поиска лидера Raft-группы и присоединения к ней происходит в дочернем процессе (голубой цвет). При сбросе состояния инстанса и rebootstrap происходит повторная инициализация форка (сиреневый цвет).

Данная схема наиболее полно отражает логику кода в файле `main.rs`. Ниже описаны детали выполнения каждого этапа и соответствующей программной функции.

### fn main()

На этом этапе происходит ветвление (форк) процесса `picodata`. Родительский процесс (supervisor) ожидает от дочернего процесса сообщения по механизму IPC и при необходимости перезапускает дочерний процесс. При необходимости дочерний процесс может попросить родителя удалить все файлы БД, т.е. вызвать функцию `drop_db`. Это может понадобиться для повторной инициализации кластера когда, например, у инстанса изначально имеется устаревший или некорректный `replicaset_id`.

### fn start_discover()

Дочерний процесс начинает своё существование с запуска модуля `box.cfg()` и вызова функции `start_discover`. Возможно, что при этом из постоянно хранимых данных будет ясно, что bootstrap данного инстанса уже был произведён ранее и что Raft уже знает о вхождении этого инстанса в кластер - в таком случае никакого discovery не будет, инстанс сразу перейдёт к этапу `postjoin()`. В противном случае, если место инстанса в кластере ещё не известно, алгоритм discovery опредяет значение флага `i_am_bootstrap_leader` и адрес лидера Raft-группы. Далее все инстансы сбрасывают своё состояние (этап rebootstrap) чтобы повторно провести инициализацию `box.cfg`, теперь уже с известными параметрами. Сам лидер (единственный с `i_am_bootstrap_leader == true`) выполняет функцию `start_boot`. Остальные инстансы переходят к функции `start_join`.

### fn start_boot()

В функции `start_boot` происходит инициализация Raft-группы - лидер генерирует и сохраняет в БД первую запись в журнале. В этой записи будет лежать операция добавления Raft-узла; все остальные инстансы будут инициализированы с пустой Raft-группой.

Сам Raft-узел на данном этапе ещё не создаётся. Это произойдет позже, на стадии `postjoin()`.

### fn start_join()

Вызову функции `start_join` всегда предшествует rebootstrap (удаление БД и перезапуск процесса), поэтому на данном этапе в БД нет ни модуля box, ни пространства хранения. Функция start_join() имеет простое устройство:

Инстанс-клиент отправляет запрос `join` лидеру Raft-группы (он известен после discovery). После достижения консенсуса в Raft-группе лидер присылает в ответе необходимую информацию:
- Идентификатор `raft_id` и данные таблицы `raft_group` - для инициализации Raft-узла;
- Идентификаторы  `instance_uuid`, `replicaset_uuid` и параметры `replication`, `read_only` для `box.cfg`.

Получив все настройки, инстанс использует их в `box.cfg()`, и затем создает в БД группу `raft_group` с актуальными адресами других инстансов. Без этого инстанс не сможет отвечать на  сообщения от Raft. Для того чтобы записи в `raft_group` не были затем заменены на менее актуальные из журнала Raft, каждая запись маркируется значением `commit_index`.

По завершении этих манипуляций инстанс также переходит к этапу `postjoin()`.

### fn postjoin()

Логика функции `postjoin()` одинакова для всех инстансов. К этому моменту для инстанса уже инициализированы корректные пространства хранения в БД и могут быть накоплены записи в журнале Raft. Инстанс инициализирует узел Raft и проверяет, что данные синхронизированы (`read barrier` получен) и журнал Raft актуален. Из журнала становятся известны параметры репликации, и инстанс начинает синхронизацию данных уровне репликационных групп Tarantool.

На данном этапе инстансу остаётся проверить свой статус voter / learner, при необходимости запросить повышение до статуса voter (повторение функции `join`, лидер известен после получения `read barrier`), и дождаться применения статуса.

Теперь узел Raft готов к использованию.

# Обработка запросов

### extern "C" fn join()

Значительная часть всей логики по управлению топологией находится в хранимой процедуре `join`. Её назначение состоит в обработке запросов на добавление нового инстанса (клиента) в Raft-группу с учётом следующих обстоятельств:

Во-первых, если такой `instance_id` уже имеется в кластере (и его данные сохранены в БД) и никакая другая информация не обновлялась (например флаг `voter` / `learner`), то можно сразу отвечать клиенту, не задействуя Raft.

Если это первое появление инстанса в группе, то он всегда добавляется в роли `learner`. В роли `voter` его добавлять нельзя, так как для достижения консенсуса в Raft-группе требуется участие добавляемого инстанса, но он не сможет участвовать, так как сам ещё ждёт ответа на запрос `join`.

Во-вторых, Raft не позволяет изменять конфигурацию, пока предыдущее изменение не было применено. Поэтому запросы `join` на лидере Raft-группы необходимо группировать и обрабатывать за один приём в отдельном потоке. Сначала накапливается пакет запросов, затем он обрабатывается, и после этого каждому инстансу возвращается индивидуальный ответ.

В-третьих, прежде чем отвечать инстансу-клиенту, надо дождаться применения изменений конфигурации. Это произойдёт после того как лидер Raft-группы выйдет из состояния `joint state` ([подробнее](https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf), §4.3). Только после этого лидер сможет вернуть клиенту данные `raft_id`, `raft_group`, `insance_uuid`, `replicaset_uuid`, `replication`, `read_only`.

- Значение `raft_id` генерируется лидером Raft-группы, причём строго последовательно и атомарно в рамках всего пакета запросов.
- Данные `raft_group` представляют собой копию таблицы с топологией кластера. Они понадобятся новому инстансу чтобы знать адреса соседей и нормально с ними общаться.
- Генерировать значения `raft_id` может только лидер Raft-группы. У любого другого узла Raft нет на это права.
