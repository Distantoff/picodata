#  Жизненный цикл инстанса

В контексте операционных систем каждый инстанс соответствует группе из
двух процессов — родительского (supervisor) и дочернего (именно он
выполняет tarantool runtime).

Красным показан родительский процесс, который запущен на всем протяжении
жизненного цикла инстанса. Вся логика, начиная с присоединения к
кластеру, и заканчивая обслуживанием клиентских запросов, происходит в
дочернем процессе (голубой цвет). Единственное предназначение
родительского процесса — иметь возможность сбросить состояние дочернего
(выполнить rebootstrap) и инициализировать его повторно (сиреневый
цвет).

Данная схема наиболее полно отражает логику кода в файле `main.rs`. Ниже
описаны детали выполнения каждого этапа и соответствующей программной
функции.

### fn main()

На этом этапе происходит ветвление (форк) процесса `picodata`.
Родительский процесс (supervisor) ожидает от дочернего процесса
сообщения по механизму IPC и при необходимости перезапускает дочерний
процесс.

Выполнение дочернего процесса начинается с вызова функции
[`start_discover()`](#fn-start_discover) и далее следует алгоритму. При
необходимости дочерний процесс может попросить родителя удалить все
файлы БД (см. раздел [Ребутстрап](#rebootstrap)). Это используется для
повторной инициализации инстанса с нормальным `replicaset_uuid` вместо
рандомного.

### Ребутстрап {: #rebootstrap }

В СУБД Tarantool имеются две особенности, из-за которых процесс инициализации
выглядит следующим образом:

1. Принадлежность инстанса тому или иному репликасету определяется в
   момент первого вызова `box.cfg()`, когда создается первый снапшот.
   Впоследствии изменить принадлежность репликасету невозможно.
2. Инициализация сервера iproto, реализующего бинарный сетевой протокол
   Tarantool, выполняется той же функцией `box.cfg()`.

В совокупности эти две особенности создают проблему "курицы и яйца":

- инстанс не может общаться по сети, пока не узнает принадлежность
  репликасету;
- принадлежность репликасету невозможно узнать без общения по сети.

Чтобы эту проблему решить, Picodata инициализируется со случайно
сгенерированными идентификаторами, а позже перезапускает процесс,
попутно очищая рабочую директорию.

### fn start_discover()

Дочерний процесс начинает свое существование с функции
[`init_common()`](#fn-init_common), в рамках которой в т.ч.
инициализируется модуль `box`. Возможно, что при этом из БД будет ясно,
что bootstrap данного инстанса уже был произведен ранее и что raft уже
знает о вхождении этого инстанса в кластер — в таком случае никакого
discovery не будет, инстанс сразу перейдет к этапу `postjoin()`. В
противном случае, если место инстанса в кластере еще не известно,
алгоритм discovery определяет значение флага `i_am_bootstrap_leader` и
адрес лидера raft-группы. Далее инстанс сбрасывает свое состояние (см.
[Ребутстрап](#rebootstrap)), чтобы повторно провести инициализацию
`box.cfg()`, теперь уже с известными параметрами. Сам лидер
(единственный с `i_am_bootstrap_leader == true`) выполняет функцию
`start_boot()`. Остальные инстансы переходят к функции `start_join()`.

### fn start_boot()

В функции `start_boot` происходит инициализация raft-группы — лидер
генерирует и сохраняет в БД первые записи в журнале. Эти записи
описывают добавление первого инстанса в пустую raft-группу и создание
начальной clusterwide-конфигурации. Таким образом достигается
однообразие кода, обрабатывающего эти записи.

Сам raft-узел на данном этапе еще не создается. Это произойдет позже, на
стадии `postjoin()`.

### fn start_join()

Вызову функции `start_join()` всегда предшествует
[ребутстрап](#rebootstrap) (удаление всех данных и перезапуск процесса),
поэтому на данном этапе в БД нет ни модуля `box`, ни пространства
хранения. Функция `start_join()` имеет простое устройство:

Инстанс отправляет запрос `rpc::join` лидеру raft-группы (он
известен после discovery), который в ответе присылает всю необходимую
для инициализации информацию:

Для инициализации raft-узла:

- идентификатор `raft_id`;
- данные таблицы `_picodata_peer_address`.

Для первичного вызова `box.cfg()`:
- идентификаторы  `instance_uuid`, `replicaset_uuid`,
- `box.cfg.replication` — список [адресов](../overview/glossary.md#address) для репликации.

Получив все настройки, инстанс использует их в `box.cfg()` (см.
[`init_common()`](#fn-init_common)), и затем создает в БД группу
`_picodata_peer_address` с актуальными адресами других инстансов. Без
этого инстанс не сможет отвечать на  сообщения от других членов
raft-группы.

По завершении этих манипуляций инстанс также переходит к этапу
`postjoin()`.

### fn postjoin()

Логика функции `postjoin()` одинакова для всех инстансов. К этому
моменту для инстанса уже инициализированы корректные пространства
хранения в БД и могут быть накоплены записи в журнале Raft.

Функция `postjoin()` выполняет следующие действия:

- инициализирует HTTP-сервер в соответствии с параметром `--http-listen`.
- запускает Lua-скрипт, указанный в аргументе `--script`;
- инициализирует узел Raft, который начинает взаимодействовать с
  raft-группой;
- в случае, если других кандидатов нет, инстанс тут же
  избирает себя лидером группы;
- устанавливает триггер `on_shutdown`, который обеспечит
  [корректное завершение работы инстанса](#graceful-shutdown).

Последним шагом инстанс оповещает кластер о том, что он готов проходить
настройку необходимых подсистем (репликации, шардинга, и т.д.). Для
этого лидеру отправляется запрос на обновление `target_grade` текущего
инстанса до уровня `Online`, после чего за дальнейшие действия будет
отвечать специальный поток управления [topology governor](#topology-governor).

Как только запись с обновленным грейдом будет зафиксирована в Raft, узел
готов к использованию.

### fn init_common()

Функция `init_common` обобщает действия, необходимые для инициализации
инстанса во всех трех вышеописанных сценариях — `start_discover`,
`start_boot`, `start_join`.

Инициализация инстанса подразумевает следующие шаги:

- создание `data_dir`;
- первичный вызов `box.cfg`;
- инициализация `package.preload.vshard`;
- инициализация хранимых процедур (`box.schema.func.create`);
- создание системных таблиц (`_picodata_raft_log` и т.д).

Параметры первичного вызова `box.cfg` зависят от конкретного сценария:

| param       | `start_discover` | `start_boot` | `start_join`                  |
|-------------|------------------|--------------|-------------------------------|
| listen      | None             | None         | _from args_                   |
| read_only   | false            | false        | from `rpc::join` response     |
| uuids       | _random_         | _given_      | from `rpc::join` response     |
| replication | None             | None         | from `rpc::join` response     |
| data_dir    | _from args_      | ...          | ...                           |
| log_level   | _from args_      | ...          | ...                           |


