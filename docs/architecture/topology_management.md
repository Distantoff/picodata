# Управление топологией

<!--------------------------------------------------------------------------—-->
## Общие сведения {: #intro }

Топологией кластера в Picodata называется совокупность конфигураций
инстансов и репликасетов, связей между ними, их состояний относительно
друг друга. Picodata хранит эту информацию в глобальных таблицах,
содержимое которых реплицируется на все узлы посредством алгоритма Raft.

Важной составляющей топологии является информация о **грейдах** всех
узлов. Данный термин является специфичным для Picodata. Он отражает не
состояние самого инстанса, а конфигурацию остальных участников кластера
по отношению к нему. Существуют две разновидности грейдов: текущий
(`current_grade`) и целевой (`target_grade`).

Управление топологией в Picodata происходит за счет последовательного
изменения грейдов: сначала меняется значения `target_grade`,
затем это значение задается в `current_grade`.

Изменение `target_grade` происходит в следующих ситуациях:

- запуск инстанса (`target_grade = Online`)
- штатное выключение инстанса (`target_grade = Offline`)
- аварийное переключение (`target_grade = Offline`)
- удаление инстанса из кластера (`target_grade = Expelled`)

Конфигурацией инстансов и обновлением `current_grade` централизованно
управляет raft-лидер. По мере появления изменений `target_grade`, он
применяет изменения к остальным инстансам кластера (к каждому в
отдельности) и обновляет `current_grade`. Реализует эту логику компонент
`governor`.

Изменить `current_grade` может только лидер при поддержке кворума, что
гарантирует консистентность принятого решения (и поддерживает доверие к
системе в плане отказоустойчивости).

Все изменения грейдов в кластере регистрируются в [журнале
аудита](../reference/audit_events.md).

<!--------------------------------------------------------------------------—-->
## Сценарии управления топологией {: #scenarios }

### Присоединение (joining) инстанса к кластеру {: #joining }

Добавление нового инстанса в работающий кластер происходит по следующему
сценарию:

- Администратор лично или средствами автоматизации запускает новый инстанс
- Инстанс в процессе инициализации определяет, что у него отсутствуют
  файлы БД
- Инстанс связывается с другими узлами (`--peer`) и определяет адрес
  текущего raft-лидера
- Инстанс отправляет raft-лидеру join-запрос, содержащий
  - его сетевой адрес (`advertise_address`)
  - и домен отказа (`failure_domain`)
  - также, опционально можно явно передать `instance_id`, `replicaset_id`
- raft-лидер, получив этот запрос, выполняет ряд транзакций в глобальные
  таблицы:
  - если требуется, `INSERT ... INTO _pico_replicaset`
  - если `instance_id` передан явно и уже добавлен в кластер, проверяет
    возможность автоматически его удалить
  - генерирует `raft_id` для инстанса, никому другому ранее не
    принадлежавший
  - инициализирует `current/target_grade = Offline`
  - `INSERT ... INTO _pico_instance`
- инстанс инициализирует БД и актуализирует свое состояние относительно
  других реплик

### Штатное выключение инстанса {: #graceful_shutdown }

Чтобы выключение инстанса прошло штатно и не имело негативных
последствий, Picodata обеспечивает соблюдение следующих условий:

- инстанс не должен оставаться голосующим, если можно его заменить
  другим
- инстанс не должен оставаться raft-лидером
<!-- - инстанс не должен оставаться лидером репликасета. -->

При срабатывании триггера `on_shutdown` инстанс сначала отправляет
лидеру запрос на изменение `target_grade = Offline`. Завершение работы
происходит после того, как будет применено соответствующее изменение
`current_grade`.

Максимальное время ожидания составляет 3 с и не настраивается. По
истечении времени инстанс в любом случае завершает свою работу.

### Аварийное переключение {: #failover }

За обслуживание отказов инстансов также отвечает raft-лидер. Суть
механизма сводится к тому, что отдельный компонент `sentinel` при
обнаружении отказа инициирует изменение `target_grade = Offline`.

Критерием отказа является невозможность доставки raft-сообщений в течение
5 секунд.

Дальнейшие действия по выводу инстанса из эксплуатации выполняет
`governor`.


<!--------------------------------------------------------------------------—-->
## Governor — централизованное управление кластером {: #governor }

Большинство механизмов, связанных с отказоустойчивостью в Picodata, так или иначе
связаны с компонентом governor. С технической точки зрения governor — это
поток управления (fiber), всегда выполняющийся на [raft-лидере](../overview/glossary.md#raft_leader).
Дальше перечислены ответственности губернатора.


### Автоматическое переключение узлов, голосующих в raft {: #governor_raft_failover }

Governor следит за выполнение ограничений, описанных [здесь](./raft_failover.md#raft_voter_failover).

<!--
### Автоматическое назначение мастеров репликасетов {: #replicaset_master_switchover }

Work in progress


### Автоматическое назначение весов шардирования {: #replicaset_weight_change }

Work in progress


### Первичное распределение бакетов {: #governor_vshard_bootstrap }

Work in progress


### Автоматическое изменение конфигурации vshard {: #governor_vshard_cfg }

Work in progress
-->

### Применение изменений кластерной схемы данных {: #governor_schema_change }

Governor гарантирует отказоустойчивость изменений кластерной схемы данных.
Подробнее алгоритм описан [здесь](./clusterwide_schema.md#two_phase_algorithm).
