# Управление топологией

<!----------------------------------------------------------------------------->

## Общие сведения {: #intro }

Топологией кластера в Picodata называется совокупность конфигураций
инстансов и репликасетов, связей между ними, их состояний относительно
друг друга. Picodata хранит эту информацию в глобальных таблицах,
содержимое которых реплицируется на все узлы посредством алгоритма Raft.

Важной составляющей топологии является информация о **грейдах** всех
узлов. Данный термин является специфичным для Picodata. Он отражает не
состояние самого инстанса, а конфигурацию остальных участников кластера
по отношению к нему. Существуют две разновидности грейдов: текущий
(`current_grade`) и целевой (`target_grade`).

Управление топологией в Picodata происходит за счет последовательного
изменения грейдов: сначала меняется значения `target_grade`,
затем это значение задается в `current_grade`.

Изменение `target_grade` происходит в следующих ситуациях:

- запуск инстанса (`target_grade = Online`)
- штатное выключение инстанса (`target_grade = Offline`)
- аварийное переключение (`target_grade = Offline`)
- удаление инстанса из кластера (`target_grade = Expelled`)

Конфигурацией инстансов и обновлением `current_grade` централизованно
управляет [raft-лидер](../overview/glossary.md#raft_leader). По мере
появления изменений `target_grade`, он применяет изменения к остальным
инстансам кластера (к каждому в отдельности) и обновляет
`current_grade`. Реализует эту логику компонент `governor`.

Изменить `current_grade` может только лидер при поддержке кворума, что
гарантирует консистентность принятого решения (и поддерживает доверие к
системе в плане отказоустойчивости).

Все изменения грейдов в кластере регистрируются в [журнале
аудита](../reference/audit_events.md).

<!----------------------------------------------------------------------------->

## Сценарии управления топологией {: #scenarios }

### Присоединение (joining) инстанса к кластеру {: #joining }

Добавление нового инстанса в работающий кластер происходит по следующему
сценарию:

- Администратор лично или средствами автоматизации запускает новый
  инстанс командой [picodata run]
- Инстанс определяет, что рабочие файлы инстанса в начале [жизненного
  цикла][instance_lifecycle] отсутствуют
- Инстанс выполняет алгоритм [discovery] — связывается с другими узлами
  из параметра [picodata run --peer] и определяет адрес текущего
  raft-лидера
- Инстанс отправляет raft-лидеру запрос [proc_raft_join], содержащий
    - его сетевой адрес `advertise_address`
    - домен отказа `failure_domain`
    - тир `tier`
    - также, опционально можно явно передать `instance_id`, `replicaset_id`
- raft-лидер, получив этот запрос, выполняет ряд транзакций в глобальные
  таблицы:
    - если переданного тира нет в таблице `_pico_tier`, запрос отклоняется
    - если требуется, `INSERT ... INTO _pico_replicaset`
    - если `instance_id` передан явно и уже добавлен в кластер, проверяет
      возможность автоматически его удалить
    - генерирует `raft_id` для инстанса, никому другому ранее не
      принадлежавший
    - инициализирует `current/target_grade = Offline`
    - `INSERT ... INTO _pico_peer_address`
    - `INSERT ... INTO _pico_instance`
- инстанс инициализирует локальную БД и актуализирует свое состояние
  относительно других реплик

[picodata run]: ../reference/cli.md#run
[discovery]: ../architecture/discovery.md
[instance_lifecycle]: ../architecture/instance_lifecycle.md
[picodata run --peer]: ../reference/cli.md#run_peer
[proc_raft_join]: ../architecture/rpc_api.md#proc_raft_join

### Штатное выключение инстанса {: #graceful_shutdown }

Чтобы выключение инстанса прошло штатно и не имело негативных
последствий, Picodata обеспечивает соблюдение следующих условий:

- инстанс не должен оставаться голосующим, если можно его заменить
  другим
- инстанс не должен оставаться raft-лидером
<!-- - инстанс не должен оставаться лидером репликасета. -->

При срабатывании триггера `on_shutdown` инстанс сначала отправляет
лидеру запрос на изменение `target_grade = Offline`. Завершение работы
происходит после того, как будет применено соответствующее изменение
`current_grade`.

Логика изменения собственного `target_grade` до `Offline` реализована в
алгоритме [`sentinel`](../overview/glossary.md#sentinel).

Максимальное время ожидания составляет 3 с и не настраивается. По
истечении времени инстанс в любом случае завершает свою работу.

### Аварийное переключение {: #failover }

За обслуживание отказов инстансов также отвечает raft-лидер и алгоритм
[`sentinel`](../overview/glossary.md#sentinel), который  при обнаружении
отказа инициирует изменение `target_grade = Offline`.

Критерием отказа является невозможность доставки raft-сообщений в течение
5 секунд.

<!----------------------------------------------------------------------------->

## Governor — централизованное управление кластером {: #governor }

Большинство механизмов, связанных с отказоустойчивостью в Picodata, так или иначе
связаны с компонентом governor. С технической точки зрения governor — это
поток управления (fiber), всегда выполняющийся на [raft-лидере](../overview/glossary.md#raft_leader).
Дальше перечислены ответственности губернатора.


### Автоматическое переключение узлов, голосующих в raft {: #governor_raft_failover }

Governor следит за выполнение ограничений, описанных [здесь](./raft_failover.md#raft_voter_failover).

<!--
### Автоматическое назначение мастеров репликасетов {: #replicaset_master_switchover }

Work in progress


### Автоматическое назначение весов шардирования {: #replicaset_weight_change }

Work in progress


### Первичное распределение бакетов {: #governor_vshard_bootstrap }

Work in progress


### Автоматическое изменение конфигурации vshard {: #governor_vshard_cfg }

Work in progress
-->

### Применение изменений кластерной схемы данных {: #governor_schema_change }

Governor гарантирует отказоустойчивость изменений кластерной схемы данных.
Подробнее алгоритм описан [здесь](./clusterwide_schema.md#two_phase_algorithm).
