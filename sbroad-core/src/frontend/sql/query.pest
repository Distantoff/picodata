Command = _{ SOI ~ (Query | ExplainQuery | Block | DDL | ACL) ~ EOF }

// Helper rule to denote we have to update plan relations from metadata
// (with Table which name corresponds to current node).
// Note that atomic specifier helps to make inner Identifier rule silent
Table     = @{ Identifier }
// Helper rule to denote we have to create relational scan node.
ScanTable = { Table }
ScanCteOrTable = @{ Table }

ACL = _{ DropRole | DropUser | CreateRole | CreateUser | AlterUser | GrantPrivilege | RevokePrivilege }
    CreateUser = {
        ^"create" ~ ^"user" ~ Identifier ~ (^"with")? ~ ^"password" ~ SingleQuotedString ~
        AuthMethod? ~ TimeoutOption?
    }
    AlterUser = {
        ^"alter" ~ ^"user" ~ Identifier ~ (^"with")? ~ AlterOption ~ TimeoutOption?
    }
        AlterOption = _{ AlterLogin | AlterNoLogin | AlterPassword | AlterRename }
            AlterLogin = { ^"login" }
            AlterNoLogin = { ^"nologin" }
            AlterPassword = { ^"password" ~ SingleQuotedString ~ AuthMethod? }
            AlterRename = { ^"rename" ~ ^"to" ~ Identifier }
	AuthMethod = { ^"using" ~ (ChapSha1 | Md5 | Ldap) }
            ChapSha1 = { ^"chap-sha1" }
            Md5 = { ^"md5" }
            Ldap = { ^"ldap" }
    DropUser = { ^"drop" ~ ^"user" ~ Identifier ~ TimeoutOption? }
    CreateRole = { ^"create" ~ ^"role" ~ Identifier ~ TimeoutOption? }
    DropRole = { ^"drop" ~ ^"role" ~ Identifier ~ TimeoutOption? }
    GrantPrivilege = { ^"grant" ~ PrivBlock ~ ^"to" ~ Identifier ~ TimeoutOption? }
    RevokePrivilege = { ^"revoke" ~ PrivBlock ~ ^"from" ~ Identifier ~ TimeoutOption? }
        PrivBlock = _{ PrivBlockPrivilege | PrivBlockRolePass }
            PrivBlockPrivilege = {Privilege ~ (PrivBlockUser | PrivBlockSpecificUser | PrivBlockRole
                                                | PrivBlockSpecificRole | PrivBlockTable | PrivBlockSpecificTable
                                                | PrivBlockProcedure | PrivBlockSpecificProcedure)}
            PrivBlockUser = { ^"user" }
            PrivBlockSpecificUser = { ^"on" ~ ^"user" ~ Identifier }
            PrivBlockRole = { ^"role" }
            PrivBlockSpecificRole = { ^"on" ~ ^"role" ~ Identifier }
            PrivBlockTable = { ^"table" }
            PrivBlockSpecificTable = { ^"on" ~ ^"table" ~ Table }
            PrivBlockRolePass = { Identifier }
            PrivBlockProcedure = { ^"procedure" }
            PrivBlockSpecificProcedure = { ^"on" ~ ^"procedure" ~ ProcWithOptionalParams }
        Privilege = _{ PrivilegeRead | PrivilegeWrite | PrivilegeExecute |
                      PrivilegeCreate | PrivilegeAlter | PrivilegeDrop |
                      PrivilegeSession | PrivilegeUsage }
            PrivilegeAlter = { ^"alter" }
            PrivilegeCreate = { ^"create" }
            PrivilegeDrop = { ^"drop" }
            PrivilegeExecute = { ^"execute" }
            PrivilegeRead = { ^"read" }
            PrivilegeSession = { ^"session" }
            PrivilegeUsage = { ^"usage" }
            PrivilegeWrite = { ^"write" }

DDL = _{ CreateTable | DropTable | CreateIndex | DropIndex
         | CreateProc | DropProc | RenameProc | SetParam | SetTransaction }
    CreateTable = {
        ^"create" ~ ^"table" ~ NewTable ~
        "(" ~ Columns ~ ("," ~ PrimaryKey)? ~ ")" ~
        Engine? ~ Distribution? ~ TimeoutOption?
    }
        NewTable = @{Table}
        Columns = { ColumnDef ~ ("," ~ ColumnDef)* }
            ColumnDef = { Identifier ~ ColumnDefType ~ ColumnDefIsNull? ~ PrimaryKeyMark? }
            ColumnDefIsNull = { NotFlag? ~ ^"null" }
            PrimaryKeyMark = { ^"primary" ~ ^"key" }
        PrimaryKey = { PrimaryKeyMark ~ "(" ~ Identifier ~ ("," ~ Identifier)* ~ ")" }
        Engine = { ^"using" ~ (Memtx | Vinyl) }
            Memtx = { ^"memtx" }
            Vinyl = { ^"vinyl" }
        Distribution = { ^"distributed" ~ (Global | Sharding) }
        Global = { ^"globally" }
        Sharding = { ^"by" ~ "(" ~ Identifier ~ ("," ~ Identifier)* ~ ")" ~ Tier? }
        Tier = { ^"in" ~ ^"tier" ~ Identifier }
    DropTable = { ^"drop" ~ ^"table" ~ Table ~ TimeoutOption? }

    CreateProc = {
        ^"create" ~ ^"procedure" ~ Identifier
        ~ ProcParams ~ (^"language" ~ ProcLanguage)?
        ~ ((^"as" ~ "$$" ~ ProcBody ~ "$$") | (^"begin" ~ "atomic" ~ ProcBody ~ "end"))
        ~ TimeoutOption?
    }
        ProcParams = { "(" ~ (ColumnDefType ~ ("," ~ ColumnDefType)*)? ~ ")" }
        ProcLanguage = { SQL }
            SQL = { ^"sql" }
        ProcBody = { (Insert | Update | Delete) }

    DropProc = { ^"drop" ~ ^"procedure" ~ ProcWithOptionalParams ~ TimeoutOption? }
        ProcWithOptionalParams = { Identifier ~ ProcParams? }

    RenameProc = { ^"alter" ~ ^"procedure" ~ OldProc ~ ProcParams? ~ ^"rename" ~ ^"to" ~ NewProc ~ TimeoutOption? }
        OldProc = @{ Identifier }
        NewProc = @{ Identifier }

    CreateIndex = {
        ^"create" ~ Unique? ~ ^"index" ~ Identifier ~ ^"on" ~ Table
        ~ IndexType? ~ "(" ~ Parts ~ ")" ~ IndexOptions? ~ TimeoutOption?
    }
    Unique = { ^"unique" }
    IndexType = { ^"using" ~ (Tree | Hash | RTree | BitSet) }
        Tree = { ^"tree" }
        Hash = { ^"hash" }
        RTree = { ^"rtree" }
        BitSet = { ^"bitset" }
    Parts = { Identifier ~ ("," ~ Identifier)* }
    IndexOptions = { ^"with" ~ "(" ~ IndexOptionParam ~ ("," ~ IndexOptionParam)* ~ ")" }
    IndexOptionParam = { BloomFpr | PageSize | RangeSize | RunCountPerLevel | RunSizeRatio
                         | Dimension | Distance | Hint }
        BloomFpr = { ^"bloom_fpr" ~ "=" ~ Decimal }
        PageSize = { ^"page_size" ~ "=" ~ Unsigned }
        RangeSize = { ^"range_size" ~  "=" ~Unsigned }
        RunCountPerLevel = { ^"run_count_per_level" ~  "=" ~Unsigned }
        RunSizeRatio = { ^"run_size_ratio" ~ "=" ~ Decimal }
        Dimension = { ^"dimension" ~ "=" ~ Unsigned }
        Distance = { ^"distance" ~ "=" ~ (Euclid | Manhattan) }
            Euclid = { ^"euclid" }
            Manhattan = { ^"manhattan" }
        Hint = { ^"hint" ~ "=" ~ (True | False) }

    DropIndex = { ^"drop" ~ ^"index" ~ Identifier ~ TimeoutOption? }

    SetParam = { ^"set" ~ SetScope? ~ ConfParam  }
        SetScope = { ScopeSession | ScopeLocal }
            ScopeSession  = { ^"session" }
            ScopeLocal    = { ^"local" }
        ConfParam = { NamedParam | TimeZoneParam }
            NamedParam    = { Identifier ~ (^"to" | "=") ~ (NamedParamValue ~ ("," ~ NamedParamValue)*) }
                NamedParamValue = { ParamValueDefault | SingleQuotedString | Identifier | Double | Decimal | Integer }
            TimeZoneParam = { ^"time" ~ ^"zone" ~ TimeZoneParamValue }
                TimeZoneParamValue = { NamedParamValue | ParamValueLocal }
        ParamValueLocal = { ^"local" }
        ParamValueDefault = { ^"default" }

    SetTransaction = { ^"set" ~ (SetTransactionSubRule | SetSessionCharacteristics) }
        SetTransactionSubRule = { ^"transaction" ~ (TransactionMode | TransactionSnapshot) }
        SetSessionCharacteristics = { ^"session" ~ ^"characteristics" ~ ^"as" ~ ^"transaction" ~ TransactionMode }
            TransactionMode = { IsolationLevel | ReadWrite | ReadOnly | Deferrable }
                IsolationLevel = { ^"isolation" ~ ^"level" ~ ConcreteIsolationLevel }
                    ConcreteIsolationLevel = _{ Serializable | RepeatableRead | ReadCommited | ReadUncommited }
                        Serializable = { ^"serializable" }
                        RepeatableRead = { ^"repeatable" ~ ^"read" }
                        ReadCommited = { ^"read" ~ ^"commited" }
                        ReadUncommited = { ^"read" ~ ^"uncommited" }
                ReadWrite  = { ^"read" ~ ^"write" }
                ReadOnly   = { ^"read" ~ ^"only" }
                Deferrable = { NotFlag? ~ ^"deferrable" }
            TransactionSnapshot = { ^"snapshot" ~ SingleQuotedString }

Block = { CallProc ~ DqlOption? }
    CallProc = { ^"call" ~ Identifier ~ "(" ~ ProcValues ~ ")" }
        ProcValues = { (ProcValue ~ ("," ~ ProcValue)*)? }
            ProcValue = _{ Literal | Parameter }

ExplainQuery = _{ Explain }
    Explain = { ^"explain" ~ Query }

Query = { (SelectFull | Values | Insert | Update | Delete) ~ DqlOption? }
    SelectFull = {
        (^"with" ~ Cte ~ ("," ~ Cte)*)?
        ~ SelectStatement
    }
    SelectStatement = {
      SelectWithOptionalContinuation ~ Limit?
    }
    Limit = { ^"limit" ~ (Unsigned | LimitAll) }
      LimitAll = { ^"all" | Null }
    SelectOp = _{ UnionAllOp | ExceptOp | UnionOp }
        UnionOp = { ^"union" }
        ExceptOp = { (^"except" ~ ^"distinct") | ^"except" }
        UnionAllOp = { ^"union" ~ ^"all" }
    SelectWithOptionalContinuation = { Select ~ (SelectOp ~ Select)* }
    Cte = { Identifier ~ ("(" ~ CteColumn ~ ("," ~ CteColumn)* ~ ")")? ~ ^"as"
            ~ "(" ~ (SelectStatement | Values) ~ ")" }
    CteColumn = @{ Identifier }
    Select = {
        ^"select" ~ Projection ~ ^"from" ~ Scan ~
        Join* ~ WhereClause? ~
        (^"group" ~ ^"by" ~ GroupBy)? ~
        (^"having" ~ Having)? ~
        (^"order" ~ ^"by" ~ OrderBy)?
    }
    Projection = { Distinct? ~ ProjectionElement ~ ("," ~ ProjectionElement)* }
        ProjectionElement = _{ Asterisk | Column }
        Column = { Expr ~ ((^"as")? ~ Identifier)? }
        Asterisk = { (Identifier ~ ".")? ~ "*" }
    WhereClause = _{ ^"where" ~ Selection }
    Selection = { Expr }
    Scan = { (ScanCteOrTable| SubQuery) ~ ((^"as")? ~ Identifier)? }
    Join = { JoinKind? ~ ^"join" ~ Scan ~ ^"on" ~ Expr }
        JoinKind = _{ ( InnerJoinKind | LeftJoinKind ) }
            InnerJoinKind = { ^"inner" }
            LeftJoinKind = { ^"left" ~ (^"outer")? }
    GroupBy = { Expr ~ ("," ~ Expr)* }
    Having = { Expr }
    OrderBy = { OrderByElement ~ ("," ~ OrderByElement)* }
        OrderByElement = { Expr ~ OrderFlag? }
        OrderFlag = _{ Asc | Desc }
            Asc = { ^"asc" }
            Desc = { ^"desc" }
    SubQuery = { "(" ~ (SelectFull | Values) ~ ")" }
    Insert = { ^"insert" ~ ^"into" ~ Table ~ ("(" ~ TargetColumns ~ ")")? ~ (SelectFull | Values) ~ OnConflict? }
        TargetColumns = { Identifier ~ ("," ~ Identifier)* }
        OnConflict = _{ ^"on conflict" ~ ^"do" ~ (DoNothing | DoReplace | DoFail) }
        DoReplace = { ^"replace" }
        DoNothing = { ^"nothing" }
        DoFail = { ^"fail" }
    Update = { ^"update" ~ ScanTable ~ ^"set" ~ UpdateList ~ (UpdateFrom | WhereClause)? }
        UpdateList = { UpdateItem ~ ("," ~ UpdateItem)* }
        UpdateItem = { Identifier ~ "=" ~ Expr }
        UpdateFrom = _{ ^"from" ~ Scan ~ (^"where" ~ Expr)? }
    Values = { ^"values" ~ Row ~ ("," ~ Row)* }

    DqlOption = _{ ^"option" ~ "(" ~ OptionParam ~ ("," ~ OptionParam)* ~ ")" }
    OptionParam = _{ SqlVdbeMaxSteps | VTableMaxRows }
    Timeout = { ^"timeout" ~ "=" ~ Duration }
       Duration = @{ Unsigned ~ ("." ~ Unsigned)? }
    TimeoutOption = _{ ^"option" ~ "(" ~ Timeout ~ ")" }
    SqlVdbeMaxSteps = { ^"sql_vdbe_max_steps" ~ "=" ~ (Unsigned | Parameter) }
    VTableMaxRows = { ^"vtable_max_rows" ~ "=" ~ (Unsigned | Parameter) }
    Delete = { ^"delete" ~ ^"from" ~ ScanTable ~ (^"where" ~ DeleteFilter)? }
    	DeleteFilter = { Expr }

Identifier = @{ DelimitedIdentifier | RegularIdentifier  }
    DelimitedIdentifier = @{ ("\"" ~ ((!("\"") ~ ANY) | "\"\"")* ~ "\"") }
    RegularIdentifier = @{ !KeywordCoverage ~
                            RegularIdentifierFirstApplicableSymbol ~
                            RegularIdentifierApplicableSymbol* ~
                            &IdentifierInapplicableSymbol }
        RegularIdentifierFirstApplicableSymbol = { !(IdentifierInapplicableSymbol | ASCII_DIGIT) ~ ANY }
        RegularIdentifierApplicableSymbol = { !IdentifierInapplicableSymbol ~ ANY }
        IdentifierInapplicableSymbol = { WHITESPACE | "." | "," | "(" | EOF | ")" | "\"" | ":"
                                       | "'" | ArithInfixOp | ConcatInfixOp | NotEq | GtEq
                                       | Gt | LtEq | Lt | Eq }
        KeywordCoverage = { Keyword ~ IdentifierInapplicableSymbol }
            // Note: In case two keywords with the same prefix are met, shorter ones must go after longest.
            //       E.g. ^"in" must go after ^"insert" because keywords traversal stops on the first match.
            //       Please, try to keep the list in alphabetical order.
            Keyword = {  ^"all" | ^"and" | ^"any" | ^"array" | ^"asc" | ^"as"
                        | ^"begin" | ^"between" | ^"boolean" | ^"bool"| ^"by"
                        | ^"case" | ^"cast" | ^"char"
                        | ^"decimal" | ^"desc" | ^"distinct" | ^"double"
                        | ^"else" | ^"end" | ^"except" | ^"exists"
                        | ^"false" | ^"from" | ^"group"
                        | ^"having" | ^"inner" | ^"integer" | ^"into" | ^"int" | ^"in" | ^"is"
                        | ^"join" | ^"left" | ^"not" | ^"null" | ^"number"
                        | ^"on" | ^"option" | ^"order" | ^"or" | ^"outer" | ^"primary"
                        | ^"scalar" | ^"select" | ^"set" | ^"string"
                        | ^"table" | ^"text" | ^"then" | ^"to" | ^"true"
                        | ^"union" | ^"unsigned" | ^"using" | ^"uuid"
                        | ^"values" | ^"varchar" | ^"when" | ^"where" | ^"with"
                        | ^"limit"
                        }

Expr = { ExprAtomValue ~ (ExprInfixOp ~ ExprAtomValue)* }
    ExprInfixOp = _{ Between | ArithInfixOp | CmpInfixOp | ConcatInfixOp | And | Or }
        Between       = { NotFlag? ~ ^"between" }
        And           = { ^"and" }
        Or            = @{ ^"or" ~ SP }
        ConcatInfixOp = { "||" }
        ArithInfixOp  = _{ Add | Subtract | Multiply | Divide }
            Add      = { "+" }
            Subtract = { "-" }
            Multiply = { "*" }
            Divide   = { "/" }
        CmpInfixOp    = _{ NotEq | GtEq | Gt | LtEq | Lt | Eq | In }
            Eq    = { "=" }
            Gt    = { ">" }
            GtEq  = { ">=" }
            Lt    = { "<" }
            LtEq  = { "<=" }
            NotEq = { "<>" | "!=" }
            In    = { NotFlag? ~ ^"in" }
    ExprAtomValue = _{ UnaryNot* ~ AtomicExpr ~ CastPostfix* ~ IsNullPostfix? }
        UnaryNot   = @{ NotFlag }
        CastPostfix = { "::" ~ ColumnDefType }
        IsNullPostfix = { ^"is" ~ NotFlag? ~ ^"null" }
        AtomicExpr = _{ Literal | Parameter | CastOp | Trim | CurrentDate | IdentifierWithOptionalContinuation | ExpressionInParentheses | UnaryOperator | Case | SubQuery | Row }
            Literal = { True | False | Null | Double | Decimal | Unsigned | Integer | SingleQuotedString }
                True     = { ^"true" }
                False    = { ^"false" }
                Null     = { ^"null" }
                Decimal = @{ Integer ~ ("." ~ ASCII_DIGIT*) }
                Double = @{ Integer ~ ("." ~ ASCII_DIGIT*)? ~ (^"e" ~ Integer) }
                Integer = @{ ("+" | "-")? ~ ASCII_DIGIT+ }
                Unsigned = @{ ASCII_DIGIT+ }
                SingleQuotedString = @{ "'" ~ ((!("'") ~ ANY) | "''")* ~ "'" }
            Parameter = { PgParameter | TntParameter }
                TntParameter = @{ "?" }
                PgParameter = { "$" ~ Unsigned }
            IdentifierWithOptionalContinuation = { Identifier ~ (ReferenceContinuation | FunctionInvocationContinuation)? }
                ReferenceContinuation          = { "." ~ Identifier }
                FunctionInvocationContinuation = { "(" ~ (CountAsterisk | FunctionArgs)? ~ ")" }
                    FunctionArgs = { Distinct? ~ (Expr ~ ("," ~ Expr)*)? }
                    CountAsterisk = { "*" }
            ExpressionInParentheses = { "(" ~ Expr ~ ")" }
            CurrentDate = { ^"current_date" }
            Trim = {
                ^"trim" ~ "("
                ~ (((TrimKind? ~ TrimPattern) | TrimKind) ~ ^"from")? ~ TrimTarget
                ~ ")"
            }
                TrimKind = { (TrimKindLeading | TrimKindTrailing | TrimKindBoth) }
                    TrimKindLeading = { ^"leading" }
                    TrimKindTrailing = { ^"trailing" }
                    TrimKindBoth = { ^"both" }
                TrimPattern = { Expr }
                TrimTarget = { Expr }
            Case = {
                ^"case" ~
                Expr? ~
                CaseWhenBlock+ ~
                CaseElseBlock? ~
                ^"end"
            }
                CaseWhenBlock = { ^"when" ~ Expr ~ ^"then" ~ Expr }
                CaseElseBlock = { ^"else" ~ Expr }
            CastOp = { ^"cast" ~ "(" ~ Expr ~ ^"as" ~ TypeCast ~ ")" }
                TypeCast = _{ TypeAny | ColumnDefType }
                ColumnDefType = { TypeBool | TypeDatetime | TypeDecimal | TypeDouble | TypeInt | TypeNumber
                                   | TypeScalar | TypeString | TypeText | TypeUnsigned | TypeVarchar | TypeUuid }
                    TypeAny = { ^"any" }
                    TypeBool = { (^"boolean" | ^"bool") }
                    TypeDatetime = { ^"datetime" }
                    TypeDecimal = { ^"decimal" }
                    TypeDouble = { ^"double" }
                    TypeInt = { (^"integer" | ^"int") }
                    TypeNumber = { ^"number" }
                    TypeScalar = { ^"scalar" }
                    TypeString = { ^"string" }
                    TypeText = { ^"text" }
                    TypeUuid = { ^"uuid" }
                    TypeUnsigned = { ^"unsigned" }
                    TypeVarchar = { ^"varchar" ~ "(" ~ Unsigned ~ ")" }
            UnaryOperator = _{ Exists }
                Exists = { NotFlag? ~ ^"exists" ~ SubQuery }
            Row = { "(" ~ Expr ~ ("," ~ Expr)* ~ ")" }

Distinct = { ^"distinct" }
NotFlag = { ^"not" }
EOF = { EOI | ";" }
WHITESPACE = _{ " " | "\t" | "\n" | "\r\n" }
// Shortened rule to include mandatory space predicate between tokens.
SP = _{ &WHITESPACE }
